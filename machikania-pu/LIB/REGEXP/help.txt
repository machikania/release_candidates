＜クラス名およびバージョン＞
REGEXP
ver 0.3

＜ファイル名＞
REGEXP.BAS

＜ライセンス＞
BASファイルは、パブリックドメイン。c/srcディレクトリー内のファイルについては、各ファイルを参照の事。HEXファイルの再頒布の際は、ソースコードを含むcディレクトリーを含める事。

＜概要＞
正規表現をMachiKaniaで使うためのクラス。実行にはCLDHEXクラスが必要。

＜コンストラクター＞
第１引数（省略可）
	正規表現の検索文字列。省略した場合は、REGEXPクラスの初期化（HEXプログラムのロード）のみを行う。
第２引数（省略可）
	パターン修飾子を含む文字列。

＜パブリックフィールド＞
なし。

＜パブリックメソッド＞
INIT(x$[,y$])
	コンストラクターを参照。

REGEXEC([x$])
	x$で示された文字列を、コンストラクターもしくはINITメソッドで指定した方法で検索する。x$を省略した場合は、2番目以降の検索を行う。マッチした場合は1を、しない場合は0を返す。

MATCH$(x)
	REGEXECでマッチした文字列を返す。x=0の時は全体のマッチを、x=1-9の時は1番目から9番目の「()」指定部分のマッチを返す。

REPLACE$(x$,y$)
	x$で示された文字列について、マッチするものをy$に変換し、返す。ただし、文字列y$中では、「$0」がマッチ0（マッチ全体）、「$1」がマッチ1、…「$9」がマッチ9に変換される。「$」や「\」を使いたい場合は、それぞれ「\$」「\\」と表記すること。

REPLACE_CALLBACK$(x$,FUNCADDRESS(yyy))
	x$で示された文字列について、マッチデーターをyyyというラベルで示されたサブルーチン（コールバック関数）に渡し、サブルーチンからの戻り値に従って変換し、返す。コールバック関数に渡される引数は1つで、マッチデーターを含む配列。配列の0番目の要素はマッチ0文字列の開始位置へのポインター、配列の10番目の要素はマッチ0文字列の終了位置へのポインター、配列の1番目の要素はマッチ0文字列の開始位置へのポインター、配列の11番目の要素はマッチ0文字列の終了位置へのポインター、など。マッチした個所は、コールバック関数の戻り値としての文字列に変換される。

＜パターン構文＞
　基本的に「regexp(3)」と呼ばれる、「egrep(1)」スタイルの正規表現です。詳細は割愛しますが、以下の制約があります。

・「.*」などによる最大サイズのマッチは行えるが、「.*?」のように「?」を追加する事での最小マッチは行えない。最小マッチを行いたい場合は「<[^>]>」のように、「[^]」表記を使うなどすること。
・「{n}」と「{min,max}」は使えるが、「{n,}」のようなn個以上の繰り返しは使えない。
・「\s」「\w」等のエスケープ文字は使えない。ただし、「\r」「\n」「\t」はMachiKaniaが認識するので使用可能。
・「^」「$」は、行の初めと終わりではなく、文字列全体の初めと終わりに一致する。行の初めや終わりを認識したい場合、改行コードにCRLFを用いて、「(?:^|\n)」「(?:\r|$)」などとすること。

＜パターン修飾子＞
　パターン修飾子としては、「i」と「s」の2つが有効。

・i: これを指定すると、英文字の大文字小文字を区別せずに検索する。指定しない場合は、大文字小文字が区別される。
・s: これを指定すると、「.」が改行を含むすべての文字にマッチする。指定しない場合は、改行以外の文字にマッチする。

＜使用例＞

「This is a simple SAMPLE.」という文字列を「(s[a-z]m)ple」で、大文字小文字の区別なく検索する例。

useclass REGEXP
r=new(REGEXP,"(s[a-z]m)ple","i")
r.regexec("This is a simple SAMPLE.")
print r.match$(0),r.match$(1)
r.regexec()
print r.match$(0),r.match$(1)

実行結果：

simple    sim
SAMPLE    SAM


文字列中の小文字をすべて大文字に変換する例。

useclass REGEXP
r=new(REGEXP,"[a-z]")
print r.replace_callback$("This is a simple SAMPLE.",funcaddress(callback))
end
label callback
var d
d=args(1)
return chr$(peek(d(0))-0x20)

実行結果：

THIS IS A SIMPLE SAMPLE.


HTMLエンティティをデコードする例

useclass REGEXP
r=new(REGEXP,"&(amp|gt|lt|quot);")
t$="HTML &amp; &quot;test&quot; &lt;br /&gt;"
print r.replace_callback$(t$,funcaddress(callback))
end
label callback
var d,a
d=args(1)
a=peek(d(1))
if 0x61=a then return "&"
if 0x67=a then return ">"
if 0x6c=a then return "<"
return "\x22"

実行結果：
HTML & "test" <br />

＜バージョン履歴＞
・Ver 0.3 連続使用時にメモリー割り当て不良を起こす問題を、解消。
・Ver 0.2 最初の公開バージョン。